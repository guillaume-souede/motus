import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Image;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JProgressBar;
import javax.swing.SwingUtilities;
import javax.swing.Timer;

public class EcranChargement extends JFrame {
    private final JProgressBar barreChargement;
    private int progress = 0;
    private final Runnable onFinished;

    public EcranChargement(Runnable onFinished) {
        this.onFinished = onFinished;

        setTitle("Chargement");
        setSize(600, 400);
        setUndecorated(true);
        setLocationRelativeTo(null);
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        ImageIcon originalIcon = new ImageIcon("images/defaut.png");
        Image scaledImage = originalIcon.getImage().getScaledInstance(600, 400, Image.SCALE_SMOOTH);
        ImageIcon scaledIcon = new ImageIcon(scaledImage);

        JLabel background = new JLabel(scaledIcon);
        background.setLayout(new BorderLayout());

        barreChargement = new JProgressBar();
        barreChargement.setStringPainted(true);
        barreChargement.setForeground(Color.GREEN);
        barreChargement.setBackground(Color.DARK_GRAY);
        barreChargement.setFont(new Font("Arial", Font.BOLD, 22)); // police plus grande
        barreChargement.setPreferredSize(new java.awt.Dimension(600, 40)); // barre plus haute
        barreChargement.setValue(0);
        barreChargement.setOpaque(true);
        barreChargement.setBorderPainted(false);
        barreChargement.setUI(new javax.swing.plaf.basic.BasicProgressBarUI() {
            protected java.awt.Dimension getPreferredInnerHorizontal() {
                return new java.awt.Dimension(600, 40);
            }
        });

        background.add(barreChargement, BorderLayout.SOUTH);
        add(background);

        Timer timer = new Timer(50, e -> updateProgress((Timer) e.getSource()));
        timer.start();
        setVisible(true);
    }

    public EcranChargement() {

        setTitle("Chargement");
        setSize(600, 400);
        setUndecorated(true);
        setLocationRelativeTo(null);
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        ImageIcon originalIcon = new ImageIcon("images/chargementImage.png");
        Image scaledImage = originalIcon.getImage().getScaledInstance(600, 400, Image.SCALE_SMOOTH);
        ImageIcon scaledIcon = new ImageIcon(scaledImage);

        JLabel background = new JLabel(scaledIcon);
        background.setLayout(new BorderLayout());

        barreChargement = new JProgressBar();
        this.onFinished = null;
        barreChargement.setStringPainted(true);
        barreChargement.setForeground(Color.GREEN);
        barreChargement.setBackground(Color.DARK_GRAY);
        barreChargement.setFont(new Font("Arial", Font.BOLD, 22)); // police plus grande
        barreChargement.setPreferredSize(new java.awt.Dimension(600, 40)); // barre plus haute
        barreChargement.setValue(0);
        barreChargement.setOpaque(true);
        barreChargement.setBorderPainted(false);
        barreChargement.setUI(new javax.swing.plaf.basic.BasicProgressBarUI() {
            protected java.awt.Dimension getPreferredInnerHorizontal() {
                return new java.awt.Dimension(600, 40);
            }
        });

        background.add(barreChargement, BorderLayout.SOUTH);
        add(background);

        Timer timer = new Timer(50, e -> updateProgress((Timer) e.getSource()));
        timer.start();
        setVisible(true);
    }

    private void updateProgress(Timer timer) {
        if (progress < 100) {
            progress += 3;
            barreChargement.setValue(progress);
        } else {
            timer.stop();
            new EcranJeu("images/defaut.png");
            dispose();
            if (onFinished != null) {
                onFinished.run(); // Trigger the next step
            }
        }
    }

    public void afficher() {
        SwingUtilities.invokeLater(() -> setVisible(true));
    }
//     public static void main(String[] args) {
//         new EcranChargement();
//     }
}
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class EcranJeu extends JFrame {
    private int essaisMax;
    private String motSecret;
    private String currentBackgroundImage = "images/defaut.png";
    private final ArrayList<String> propositions = new ArrayList<>();
    private final GrilleMotusPanel grillePanel;
    private final JTextField inputField = new JTextField(10);
    private final JButton validerBtn = new JButton("Valider");
    private final JLabel progressionLabel = new JLabel("/");
    private boolean jeuTermine = false;
    protected String mode;

    // variables pour le mode IA
    protected String progVraie = "";
    HashMap<Integer,Character> charsMalPlace = new HashMap<>();
    String charImpossible;
    ArrayList<String> dicoMots = new ArrayList<>();

    private boolean tutorielActif = false;
    private JCheckBoxMenuItem tutorielMenuItem; // R√©f√©rence √† l'item Tutoriel

    @SuppressWarnings("unused")
    public EcranJeu(String bgPath) {
        super("Motus");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());

        addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                int width = getWidth(), height = getHeight();
                setTitle("Motus (" + width + "x" + height + ")");
            }
        });

        grillePanel = new GrilleMotusPanel(6, 6, bgPath);
        essaisMax = 6;

        JScrollPane scrollPane = new JScrollPane(grillePanel,
                                                JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
                                                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setOpaque(false);
        scrollPane.getViewport().setOpaque(false);
        scrollPane.setBorder(null);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);
        add(scrollPane, BorderLayout.CENTER);

        JPanel inputPanel = new JPanel(new BorderLayout());

        // Gauche
        JPanel leftPanel = new JPanel();
        JComboBox<String> modeComboBox = new JComboBox<>(new String[]{"üë®", "ü§ñ"});
        mode = modeComboBox.getSelectedItem()+"";
        JButton resetBtn = new JButton("‚ü≥");

        leftPanel.add(new JLabel("Mode"));
        leftPanel.add(modeComboBox);
        leftPanel.add(resetBtn);

        // Centre
        JPanel centerPanel = new JPanel();
        centerPanel.add(new JLabel("Proposition"));
        centerPanel.add(inputField);
        centerPanel.add(progressionLabel);
        centerPanel.add(validerBtn);

        // Droite
        JPanel rightPanel = new JPanel();
        JButton optionsBtn = new JButton("‚öô");
        JPopupMenu popupMenu = createPopupMenu();
        optionsBtn.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                popupMenu.show(optionsBtn, optionsBtn.getWidth() / 2, -popupMenu.getPreferredSize().height);
            }
        });
        rightPanel.add(optionsBtn);

        inputPanel.add(leftPanel, BorderLayout.WEST);
        inputPanel.add(centerPanel, BorderLayout.CENTER);
        inputPanel.add(rightPanel, BorderLayout.EAST);

        add(inputPanel, BorderLayout.SOUTH);

        // Listeners ComboBox
        modeComboBox.addActionListener(e -> {
            int taille = 6; // Toujours reset √† 6 colonnes par d√©faut
            String selectedMode = (String) modeComboBox.getSelectedItem();
            mode = selectedMode;
            mettreAJourMotSecret(selectedMode, taille);

            // Reset complet de la grille et du jeu
            grillePanel.setColonnes(taille);
            grillePanel.majGrille(new ArrayList<>(), null);
            propositions.clear();
            inputField.setText("");
            inputField.setEnabled(true);
            validerBtn.setEnabled(false);
            progressionLabel.setText("0/6-9");
            progressionLabel.setForeground(Color.RED);

            // Remettre le th√®me par d√©faut
            currentBackgroundImage = "images/defaut.png";
            grillePanel.setBackgroundImage(currentBackgroundImage);
        });

        resetBtn.addActionListener(e -> {
            int taille = grillePanel.getColonnes(); // R√©cup√©rer la taille actuelle
            mettreAJourMotSecret((String) modeComboBox.getSelectedItem(), taille); // Mettre √† jour le mot secret
            resetChamp(); // R√©initialiser l'√©tat du jeu
        });

        inputField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyReleased(KeyEvent e) {
                String text = inputField.getText().trim();
                int currentLength = text.length();

                if ("ü§ñ".equals(mode)) {
                    // Activer le bouton "Valider" uniquement si la longueur est entre 6 et 9
                    boolean isValid = currentLength >= 6 && currentLength <= 9;
                    validerBtn.setEnabled(isValid);

                    // Mettre √† jour l'affichage de progression
                    progressionLabel.setText(currentLength + "/6-9");
                    progressionLabel.setForeground(isValid ? Color.GREEN : Color.RED);
                } else {
                    if (motSecret == null) {
                        // Premi√®re saisie : taille libre entre 6 et 9
                        boolean isValid = currentLength >= 6 && currentLength <= 9;
                        validerBtn.setEnabled(isValid);
                        progressionLabel.setText(currentLength + "/6-9");
                        progressionLabel.setForeground(isValid ? Color.GREEN : Color.RED);
                    } else {
                        // Mode joueur : Activer le bouton "Valider" uniquement si la longueur correspond au mot secret
                        boolean isValid = currentLength == motSecret.length();
                        validerBtn.setEnabled(isValid);

                        // Mettre √† jour l'affichage de progression
                        progressionLabel.setText(currentLength + "/" + motSecret.length());
                        progressionLabel.setForeground(isValid ? Color.GREEN : Color.RED);
                    }
                }
            }
        });

        inputField.addActionListener(e -> validerBtn.doClick());

        validerBtn.addActionListener(e -> {
            if ("ü§ñ".equals(mode)) {
                String motMystere = inputField.getText().trim().toUpperCase();

                motSecret = motMystere; // d√©finir le mot myst√®re pour le bot

                // AJOUTER CETTE LIGNE POUR ADAPTER LA GRILLE
                grillePanel.setColonnes(motSecret.length());
                grillePanel.majGrille(new ArrayList<>(), motSecret);

                // initialiser les variables pour le bot
                progVraie = "";
                charsMalPlace = new HashMap<>();
                charImpossible = "";

                // v√©rifier si motSecret est bien initialis√©
                if (motSecret == null || motSecret.isEmpty()) {
                    JOptionPane.showMessageDialog(this, "Le mot myst√®re n'a pas √©t√© d√©fini !");
                    return;
                }

                // initialiser les variables pour le bot d'apr√®s LogiqueBot.java
                progVraie = motSecret.charAt(0) + ""; // initialiser la premi√®re lettre
                for (int i = 1; i < motSecret.length()-1; i++) {
                    progVraie += "*"; // initialiser la progression avec des √©toiles
                }
                charsMalPlace.clear(); // r√©initialiser les caract√®res mal plac√©s
                charImpossible = ""; // r√©initialiser les caract√®res impossibles
                OuvrirDB db = new OuvrirDB("data/motsMotus.txt");
                dicoMots = new ArrayList<>();
                dicoMots = db.getOnePhrase(motSecret.length()); // charger le dictionnaire pour le bot
                
                // faire jouer le bot d'apr√®s LogiqueBot.java
                int essais = 0;
                boolean motTrouve = false;

                while (essais < essaisMax && !motTrouve) {
                    // filtrer les mots possibles avec la m√©thode choix
                    dicoMots = LogiqueBot.choix(progVraie, charsMalPlace, charImpossible, dicoMots);
                    if (dicoMots.isEmpty()) {
                        // JOptionPane.showMessageDialog(this, "Le bot n'a plus de mots possibles !");
                        break;
                    }

                    // choisir un mot al√©atoire parmi les mots possibles
                    String proposition = LogiqueBot.randomWord(dicoMots).toLowerCase();
                    propositions.add(proposition.toUpperCase());
                    grillePanel.majGrille(propositions, motSecret); // mettre √† jour la grille

                    // v√©rifier si le mot propos√© est correct
                    if (proposition.equals(motSecret.toLowerCase())) {
                        terminerJeu(true, "Motus en " + (essais + 1) + " essais !");
                        motTrouve = true;
                    } else {
                        // mettre √† jour les indices pour le bot
                        charsMalPlace = EtatMot.checkWrongPlacement2(motSecret.toLowerCase(),proposition);
                        charImpossible += EtatMot.getImpossibleChars(motSecret.toLowerCase(),proposition);
                        progVraie = EtatMot.updateProgVraie(motSecret.toLowerCase(), proposition);
                    }

                    essais++;
                    // try {
                    //     Thread.sleep(1000); // pause pour simuler le temps de r√©flexion du bot
                    // } catch (InterruptedException e1) {
                    //     e1.printStackTrace();
                    // }
                }

                if (!motTrouve) {
                    if (!dicoMots.contains(motSecret.toLowerCase())) {
                        terminerJeu(false, "Mot impossible.");
                    } else {
                        terminerJeu(false, "Perdu ! Le mot √©tait : " + motSecret);
                    }
                }
            } else {
                traiterProposition(mode); // Mode joueur
            }
        });

        setSize(900, 700);
        setLocationRelativeTo(null);
        setVisible(true);

        modeComboBox.setSelectedIndex(0);
        validerBtn.setEnabled(false);
        progressionLabel.setText("0/6-9"); //ok

        // Forcer le mode tutoriel au premier lancement
        SwingUtilities.invokeLater(() -> {
            if (tutorielMenuItem != null && !tutorielMenuItem.isSelected()) {
                tutorielMenuItem.doClick();
            }
        });
    }

    private void resetChamp() {
        propositions.clear();
        grillePanel.majGrille(propositions, motSecret);
        grillePanel.setBackgroundImage(currentBackgroundImage);
        inputField.setEnabled(true);
        validerBtn.setEnabled(false);
        inputField.setText("");
        progressionLabel.setText("0/6-9"); // <-- Toujours afficher 0/6-9 au reset
        jeuTermine = false;
    }

    private void traiterProposition(String mode) {
        if ("ü§ñ".equals(mode)) {
            String motMystere = inputField.getText().trim().toUpperCase();
            if (motMystere.length() < 6 || motMystere.length() > 9) {
                progressionLabel.setText("Mot invalide !");
                progressionLabel.setForeground(Color.RED);
                return;
            }
            motSecret = motMystere; // D√©finir le mot myst√®re pour le Bot
            inputField.setEnabled(false); // D√©sactiver le champ de saisie
            validerBtn.setEnabled(false); // D√©sactiver le bouton valider


            // Faire jouer le Bot
            int essais = 0;
            boolean motTrouve = false;
            while (essais < essaisMax && !motTrouve) {
                dicoMots = LogiqueBot.choix(progVraie, charsMalPlace, charImpossible, dicoMots);
                String proposition = LogiqueBot.randomWord(dicoMots);
                propositions.add(proposition);
                grillePanel.majGrille(propositions, motSecret); // Mettre √† jour la grille

                if (proposition.equals(motSecret)) {
                    grillePanel.setBackgroundImage("images/victoire.png");
                    progressionLabel.setText("Motus en " + (essais + 1) + " essais !");
                    progressionLabel.setForeground(Color.GREEN);
                    motTrouve = true;
                } else {
                    // Mettre √† jour les indices pour le Bot
                    charsMalPlace = EtatMot.checkWrongPlacement2(motSecret, proposition);
                    charImpossible += EtatMot.getImpossibleChars(motSecret, proposition);
                    progVraie = EtatMot.updateProgVraie(motSecret, proposition);
                }

                essais++;
            }

            inputField.setEnabled(false);
            validerBtn.setEnabled(false);
        } else {
            // Mode joueur
            String prop = inputField.getText().trim().toUpperCase();
            if (motSecret == null) {
                // Premi√®re proposition : d√©finir la taille et tirer le mot secret
                OuvrirDB db = new OuvrirDB("data/motsMotus.txt");
                motSecret = db.getRandomWord(prop.length());
                grillePanel.setColonnes(prop.length());
                progressionLabel.setText(prop.length() + "/6-9");
                progressionLabel.setForeground(Color.GREEN);
            }

            // Ensuite, v√©rifier la taille
            if (prop.length() != motSecret.length() || propositions.size() >= essaisMax) return;

            if (prop.equals(motSecret)) {
                propositions.add(prop);
                grillePanel.majGrille(propositions, motSecret);
                terminerJeu(true, "Motus en " + propositions.size() + " essais !");
                // Ne pas r√©activer inputField apr√®s victoire
            } else {
                propositions.add(prop);
                grillePanel.majGrille(propositions, motSecret);
                if (propositions.size() == essaisMax) {
                    terminerJeu(false, "Perdu ! Le mot √©tait : " + motSecret);
                    return;
                }
            }

            // Ne r√©activer inputField que si le jeu n'est pas termin√©
            if (!jeuTermine) {
                inputField.setEnabled(true);
                validerBtn.setEnabled(false);
                inputField.setText("");
            }
        }
        System.out.println("motSecret : " + motSecret);
    }

    private void mettreAJourMotSecret(String mode, int taille) {
        motSecret = null;
        inputField.setText("");
        validerBtn.setEnabled(false);
        progressionLabel.setText("0/6-9"); // !!! Toujours afficher 0/6-9
        progressionLabel.setForeground(Color.RED);

        if ("ü§ñ".equals(mode)) {
            OuvrirDB db = new OuvrirDB("data/motsMotus.txt");
            dicoMots = db.getOnePhrase(taille);
        }
    }

    @SuppressWarnings("unused")
    private JPopupMenu createPopupMenu() {
        JPopupMenu menu = new JPopupMenu();

        JMenu essaisMenu = new JMenu("Essais");
        ButtonGroup essaisGroup = new ButtonGroup();
        for (int i = 1; i <= 6; i++) {
            JRadioButtonMenuItem essaisItem = new JRadioButtonMenuItem(String.valueOf(i));
            int value = i;
            essaisItem.addActionListener(e -> {
                essaisMax = value;
                grillePanel.setLignes(value);
                propositions.clear();
                grillePanel.majGrille(propositions, motSecret);
            });
            essaisGroup.add(essaisItem);
            essaisMenu.add(essaisItem);
        }

        JMenu themeMenu = new JMenu("Th√®me");
        ButtonGroup themeGroup = new ButtonGroup();

        JRadioButtonMenuItem hiver = new JRadioButtonMenuItem("Hiver");
        hiver.addActionListener(e -> {
            currentBackgroundImage = "images/hiver.png";
            grillePanel.setBackgroundImage(currentBackgroundImage);
        });

        JRadioButtonMenuItem defaut = new JRadioButtonMenuItem("D√©faut");
        defaut.addActionListener(e -> {
            currentBackgroundImage = "images/defaut.png";
            grillePanel.setBackgroundImage(currentBackgroundImage);
        });

        JRadioButtonMenuItem reel = new JRadioButtonMenuItem("R√©aliste");
        reel.addActionListener(e -> {
            currentBackgroundImage = "images/reel.png";
            grillePanel.setBackgroundImage(currentBackgroundImage);
        });

        JRadioButtonMenuItem reelHiver = new JRadioButtonMenuItem("R√©aliste 2");
        reelHiver.addActionListener(e -> {
            currentBackgroundImage = "images/reelHiver.png";
            grillePanel.setBackgroundImage(currentBackgroundImage);
        });

        themeGroup.add(hiver); themeGroup.add(defaut);
        themeMenu.add(hiver); themeMenu.add(defaut);
        themeGroup.add(reel); themeGroup.add(reelHiver);
        themeMenu.add(reel); themeMenu.add(reelHiver);

        JCheckBoxMenuItem tutorielItem = new JCheckBoxMenuItem("Tutoriel");
        tutorielMenuItem = tutorielItem; // Stocker la r√©f√©rence

        // fond coch√©/d√©coch√©
        tutorielItem.addItemListener(e -> {
            if (tutorielItem.isSelected()) {
                tutorielItem.setBackground(new Color(0, 120, 255)); // Bleu
                tutorielItem.setForeground(Color.WHITE); // Texte blanc
            } else {
                tutorielItem.setBackground(null); // Fond d√©faut
                tutorielItem.setForeground(null); // Texte d√©faut
            }
        });

        tutorielItem.addActionListener(e -> {
            if (!tutorielActif) {
                // mode tutoriel
                grillePanel.setLignes(1);
                essaisMax = 1;
                grillePanel.setColonnes(8); // "TUTORIEL" = 8 lettres
                currentBackgroundImage = "images/tutoriel.png";
                tutorielActif = true;
                motSecret = "TUTORIEL";
                tutorielItem.setSelected(true);
                resetChamp();
                try {
                    // Remplacer l'ancien appel incorrect par le bon constructeur
                    new EcranRegle(this);
                } catch (FileNotFoundException e1) {}
            } else {
                // D√©sactiver le mode tutoriel (remettre les valeurs par d√©faut)
                grillePanel.setLignes(6);
                essaisMax = 6;
                grillePanel.setColonnes(6);
                currentBackgroundImage = "images/defaut.png";
                tutorielActif = false;
                motSecret = null;
                tutorielItem.setSelected(false);
                resetChamp();
            }
        });

        JMenuItem quitter = new JMenuItem("Quitter");
        quitter.addActionListener(e -> System.exit(0));

        menu.add(essaisMenu);
        menu.add(themeMenu);
        menu.add(tutorielItem); // <-- coche automatique
        menu.add(quitter);
        return menu;
    }

    private void terminerJeu(boolean gagne, String message) {
        jeuTermine = true;
        inputField.setEnabled(false);
        validerBtn.setEnabled(false);

        if (gagne && message != null && !message.isEmpty()) {
            progressionLabel.setText(message);
            progressionLabel.setForeground(Color.GREEN);
        } else if (!gagne && message != null && !message.isEmpty()) {
            progressionLabel.setText(message);
            progressionLabel.setForeground(Color.RED);
        }
    }
}
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.FileNotFoundException;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextArea;

public class EcranRegle extends JFrame {
    private final JFrame ecranJeu;

    public EcranRegle(JFrame ecranJeu) throws FileNotFoundException {
        super("R√®gles du Motus");
        this.ecranJeu = ecranJeu;

        // layout
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setLayout(new BorderLayout());

        JTextArea paneRegles = new JTextArea();
        String stringRegle = OuvrirDB.lireRegle("data/rules.txt");
        paneRegles.setText(stringRegle);
        paneRegles.setEditable(false);
        paneRegles.setLineWrap(true); // retour √† la ligne
        paneRegles.setWrapStyleWord(true); // couper les lignes
        paneRegles.setFont(new Font("Arial", Font.PLAIN, 14)); 
        paneRegles.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // marges

        // JScrollPane pour le d√©filement
        JScrollPane scrollPane = new JScrollPane(paneRegles);

        // Bouton retour
        JButton quiterButton = new JButton("Retour");
        quiterButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent clic) {
                dispose();
                if (EcranRegle.this.ecranJeu == null) {
                    new Main();
                }
                // Sinon, rien √† faire : EcranJeu reste affich√©
            }
        });

        add(scrollPane, BorderLayout.CENTER);
        add(quiterButton, BorderLayout.LINE_END);

        // ajout jaquettes jeux
        JPanel jaquettesPanel = new JPanel();
        jaquettesPanel.setLayout(new FlowLayout()); //FlowLayout pour alignement horiz

        String[] images = {"images/crevettes1.jpeg", "images/crevettes2.jpeg", "images/crevettes3.jpeg", "images/crevettes4.jpeg"};

        // Redimensionnement jaquettes jeux
        for (String imagePath : images) {
            ImageIcon originalIcon = new ImageIcon(imagePath);
            Image img = originalIcon.getImage();
            Image scaledImg = img.getScaledInstance((int)(originalIcon.getIconWidth() * 0.2), 
                                                     (int)(originalIcon.getIconHeight() * 0.2), 
                                                     Image.SCALE_SMOOTH);
            ImageIcon scaledIcon = new ImageIcon(scaledImg); 
            JLabel imageLabel = new JLabel(scaledIcon);
            jaquettesPanel.add(imageLabel);
        }

        // Ajouter le titre et le panneau des jaquettes sous les r√®gles
        add(jaquettesPanel, BorderLayout.PAGE_END);

        // Ajouter un panneau pour la recherche de mots
        JPanel searchPanel = new JPanel();
        searchPanel.setLayout(new FlowLayout());

        // Cr√©er un JComboBox avec les lettres de l'alphabet
        String[] alphabet = "ABCDEFGHIJKLMNOPQRSTV".split("");
        // String[] alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

        JComboBox<String> letterSelector = new JComboBox<>(alphabet);

        // Ajouter un ActionListener au JComboBox
        letterSelector.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                String letter = (String) letterSelector.getSelectedItem();

                try {
                    java.util.List<String> mots = new java.util.ArrayList<>();
                    java.nio.file.Files.lines(java.nio.file.Paths.get("data/motsMotus.txt"))
                        .filter(line -> line.toUpperCase().startsWith(letter))
                        .forEach(mots::add);

                    if (mots.isEmpty()) {
                        JOptionPane.showMessageDialog(null, "Aucun mot trouv√© pour la lettre : " + letter);
                    } else {
                        // Convertir les mots en tableau pour JTable
                        String[][] data = new String[mots.size()][1];
                        for (int i = 0; i < mots.size(); i++) {
                            data[i][0] = mots.get(i);
                        }

                        // Colonnes du tableau
                        String[] columnNames = {"Mots"};

                        // Cr√©er et afficher la JTable dans une nouvelle fen√™tre
                        JTable table = new JTable(data, columnNames);
                        JScrollPane scrollPane = new JScrollPane(table);
                        table.setFillsViewportHeight(true);

                        JFrame tableFrame = new JFrame("Mots commen√ßant par " + letter);
                        tableFrame.add(scrollPane);
                        tableFrame.setSize(400, 300);
                        tableFrame.setLocationRelativeTo(null);
                        tableFrame.setVisible(true);
                    }
                } catch (java.io.IOException ex) {
                    JOptionPane.showMessageDialog(null, "Erreur : " + ex.getMessage());
                }
            }
        });

        // Ajouter les composants au panneau de recherche
        searchPanel.add(new JLabel("Dico' rapide :"));
        searchPanel.add(letterSelector);

        // Ajouter le panneau de recherche au haut de la fen√™tre
        add(searchPanel, BorderLayout.NORTH);

        // Param√©trage fen√™tre
        setSize(600, 600);
        setVisible(true);
    }

//     public static void main(String[] args) throws FileNotFoundException {
//         new EcranRegle(null);
//     }
}
import java.util.ArrayList;
import java.util.HashMap;

public class EtatMot {
    /*
     * √† partir d'une proposition test quels sont les bons caract√®re
     * renvoie 2 String : 
     *  - Le premier compos√© de lettres aux bons endroits et '*' aux mauvais endroit.
     *  - Les secondRenvoie aussi les char mal plac√©
     */


    static public String checkEtatMot(String proposition, String motSecret){
        // √©tape 1 cr√©ation du premier String 
        String SilhouetteMot = "";                   // la construction du premier String
        char lettreActu;                            // le char a v√©rifier
        for (int i = 0; i < proposition.length(); i++) {
            if (proposition.charAt(i) == motSecret.charAt(i)) {
                lettreActu = proposition.charAt(i); // si bon => met dans la chaine le char
                SilhouetteMot += lettreActu;         // la concat√©nation
            } else {
                SilhouetteMot += '*';                //si pas bon met une √©toile
            }
        }
        return SilhouetteMot;
    }

        // √©tape 2 cr√©ation du String de mots mal plac√©
    static public String checkWrongPlacement(String proposition, String motSecret){
        String silouetteMot = checkEtatMot(proposition, motSecret);
        ArrayList<Integer> positionFausses= new ArrayList<Integer>();
        String motMalPlace = "";

        // a. get les positions non justes
        for (int i = 0; i < silouetteMot.length(); i++) {
            if (silouetteMot.charAt(i) == '*'){
                positionFausses.add(i);
            }
        }// en sortie on a les position fausses dasn positionsFausses

        // b. sortir les 2 chars des fausses positions
        String propositionTrimmed = "", motSecretTrimmed = "";
        for (int positions : positionFausses) {
            propositionTrimmed += proposition.charAt(positions)+""; // techniquement le +"" n'est pas n√©c√©ssaire pour la concat√©nation
            motSecretTrimmed += motSecret.charAt(positions)+"";
        }

        // avec un while pour un code de sortie
        for (int i = 0; i < propositionTrimmed.length(); i++) {
            char tempChar = propositionTrimmed.charAt(i);
            boolean pasTrouve = true;           int j = 0;
            while ( j < motSecretTrimmed.length() && pasTrouve) {
                if (tempChar == motSecretTrimmed.charAt(j)) {
                    motMalPlace += tempChar;
                    pasTrouve = false;
                }
                j ++;
            }
        }
        return motMalPlace;
    }

    static String emojiRepresentation(String proposition, String motSecret) {
        // passer de StringBuilder √† juste String car plus simple a comprendre
        String affichageEmoji = "";
        for (int i = 0; i < motSecret.length(); i++) {
            char lettre = proposition.charAt(i);
            if (lettre == motSecret.charAt(i)) {
                affichageEmoji +=("üü¶");
            } else if (motSecret.contains(String.valueOf(lettre))) {
                affichageEmoji+=("üü°");
            } else {
                affichageEmoji+=("üü•");
            }
        }
        return affichageEmoji;
    }

    static String extractImpossiblechar(String proposition, String motSecret){
        // legacy function
        String outString = ""; // stocke les char impossible pour le mot
        for (int i = 0; i < proposition.length(); i++) {
            if (motSecret.contains(proposition.charAt(i)+"") == false) {
                outString += proposition.charAt(i);
            }
        }
        return outString;
    }

    static HashMap<Integer,Character> checkWrongPlacement2(String motSecret,String proposition ){
        HashMap<Integer,Character> mauvaisePosBonChar = new HashMap<>();
        for (int i = 0; i < proposition.length(); i++) {
            if (motSecret.contains(proposition.charAt(i)+"") == true && proposition.charAt(i) != motSecret.charAt(i)) { // si le char est dans le mot secret mais pas √† la bonne position
            mauvaisePosBonChar.put(i, proposition.charAt(i)) ; // on ajoute la position en clef et le char mal pla√© en valeur
            }
        }
        return mauvaisePosBonChar;
    }

    static void pprint(String proposition, String motSecret){
        System.out.println(checkEtatMot(proposition, motSecret));
        System.out.println("lettres malplac√©es : "+checkWrongPlacement(proposition, motSecret));
        System.out.println(emojiRepresentation(proposition, motSecret));
    }




    public static String getImpossibleChars(String motSecret, String proposition) {
        StringBuilder impossibleChars = new StringBuilder();
        for (char c : proposition.toCharArray()) {
            if (!motSecret.contains(String.valueOf(c))) {
                impossibleChars.append(c);
            }
        }
        return impossibleChars.toString();
    }

    public static String updateProgVraie(String motSecret, String proposition) {
        char[] progArray = new char[motSecret.length()];
        for (int i = 0; i < motSecret.length(); i++) {
            if (proposition.charAt(i) == motSecret.charAt(i)) {
                progArray[i] = motSecret.charAt(i);
            } else {
                progArray[i] = '*'; // Placeholder for unknown characters
            }
        }
        return new String(progArray);
    }
    //     public static void main(String[] args) {
    //     // bloc de test
    //     String propostion= "partir";
    //     String motSecret = "patate";
    //     System.out.println(checkEtatMot(propostion, motSecret));
    //     System.out.println(checkWrongPlacement(propostion, motSecret));
    //     System.out.println(emojiRepresentation(propostion, motSecret));
    // }
}import java.awt.*;
import java.util.ArrayList;
import javax.swing.*;

public class GrilleMotusPanel extends JPanel {
    private int lignes;
    private int colonnes;
    private Image bgImage;
    private ArrayList<String> propositions = new ArrayList<>();
    private String motSecret = "";

    private final Color rouge = Color.decode("#de4649");
    private final Color jaune = Color.decode("#deb138");
    private final Color bleu = Color.decode("#329ddc");

    public GrilleMotusPanel(int lignes, int colonnes, String bgPath) {
        this.lignes = lignes;
        this.colonnes = colonnes;
        try {
            this.bgImage = new ImageIcon(bgPath).getImage();
        } catch (Exception e) {
            this.bgImage = null;
        }
        setOpaque(false);
        setPreferredSize(new Dimension(600, 600));
    }

    public void setLignes(int lignes) {
        this.lignes = lignes;
        repaint();
    }

    public void setColonnes(int colonnes) {
        this.colonnes = colonnes;
        repaint();
    }

    public int getColonnes() {
        return colonnes;
    }

    public void setBackgroundImage(String imagePath) {
        try {
            this.bgImage = new ImageIcon(imagePath).getImage();
        } catch (Exception e) {
            this.bgImage = null;
        }
        repaint();
    }

    public void majGrille(ArrayList<String> propositions, String motSecret) {
        this.propositions = new ArrayList<>(propositions);
        this.motSecret = motSecret;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        // Dessiner l'image de fond
        if (bgImage != null) {
            g.drawImage(bgImage, 0, 0, getWidth(), getHeight(), this);
        }

        // Facteurs de mise √† l'√©chelle
        double echelleX = getWidth() / 1536.0;
        double echelleY = getHeight() / 1024.0;

        int caseLargeur = (int) (84 * echelleX);
        int caseHauteur = (int) (90 * echelleY);
        int espacementX = (int) (3 * echelleX);
        int espacementY = (int) (3 * echelleY);

        // Centrage de la grille sur l'arri√®re-plan (AP)
        int largeurGrille = colonnes * caseLargeur + (colonnes - 1) * espacementX;
        int intervalleMin = (int) (341 * echelleX);
        int intervalleMax = (int) (1137 * echelleX);
        int grilleX = intervalleMin + (intervalleMax - intervalleMin - largeurGrille) / 2;
        int grilleY = (int) (450 * echelleY) + 10 ; // Position verticale ajust√©e

        // D√©finir la taille de la police
        int fontSize = caseHauteur * 2 / 3;
        g.setFont(new Font("Arial", Font.BOLD, fontSize));
        g.setColor(Color.WHITE);

        // Dessiner les cases de la grille
        for (int i = 0; i < lignes; i++) {
            String prop = (i < propositions.size()) ? propositions.get(i) : "";
            for (int j = 0; j < colonnes; j++) {
                int x = grilleX + j * (caseLargeur + espacementX);
                int y = grilleY + i * (caseHauteur + espacementY);

                // D√©terminer la couleur de la case
                Color couleur = bleu;
                if (i < propositions.size() && j < prop.length()) {
                    char c = prop.charAt(j);
                    if (j < motSecret.length() && c == motSecret.charAt(j)) {
                        couleur = rouge;
                    } else if (motSecret.contains(String.valueOf(c))) {
                        couleur = jaune;
                    }
                }

                // Dessiner la case (sans bords arrondis)
                g.setColor(couleur);
                g.fillRect(x, y, caseLargeur, caseHauteur);

                // Dessiner le texte dans la case
                if (i < propositions.size() && j < prop.length()) {
                    char c = prop.charAt(j);
                    g.setColor(Color.WHITE);
                    drawCenteredString(g, String.valueOf(c), x, y, caseLargeur, caseHauteur);
                }
            }
        }
    }

    private void drawCenteredString(Graphics g, String text, int x, int y, int w, int h) {
        FontMetrics metrics = g.getFontMetrics(g.getFont());
        int tx = x + (w - metrics.stringWidth(text)) / 2;
        int ty = y + ((h - metrics.getHeight()) / 2) + metrics.getAscent();
        g.drawString(text, tx, ty);
    }
}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

public class LogiqueBot {

    // m√©thode pour filtrer les mots du dictionnaire en fonction des contraintes
    static public ArrayList<String> choix(String progVraie, HashMap<Integer, Character> charsMalPlace, String charImpossible, ArrayList<String> dicoMots) {

        ArrayList<String> outDict = new ArrayList<>(dicoMots); // liste des mots filtr√©s
        ArrayList<String> foodict = new ArrayList<>(); // liste tampon pour la construction dynamique

        int propositionTaille = progVraie.length();

        // √©tape 1 : filtrer les mots qui n'ont pas le bon caract√®re √† la bonne position
        for (int i = 0; i < propositionTaille; i++) {
            String charAt = progVraie.charAt(i)+""; // caract√®re √† la position actuelle
            if (!charAt.equals("*")) { // ignorer les positions marqu√©es par un ast√©risque
                for (String mot : dicoMots) {
                    if (String.valueOf(mot.toUpperCase().charAt(i)).equals(charAt)) {
                        outDict.add(mot); // ajouter les mots qui respectent la contrainte
                    } else {
                        if (outDict.contains(mot) && !String.valueOf(mot.charAt(i)).equals(charAt)) {
                            outDict.remove(mot); // retirer les mots qui ne respectent pas la contrainte
                        }
                    }
                }}
        }

        foodict = new ArrayList<>(outDict); // mise √† jour de la liste tampon

        // √©tape 2 : filtrer les mots qui n'ont pas les bons caract√®res √† la mauvaise position
        if (outDict != null) {
            for (String mot : outDict) {
                for (Character charmalplace : charsMalPlace.values()) {
                    if (testCharMalPlace(mot, charmalplace+"")) { // v√©rifier si le mot contient les caract√®res mal plac√©s
                        foodict.add(mot); // ajouter les mots qui contiennent les caract√®res mal plac√©s
                    } else {
                        foodict.remove(mot); // retirer les mots qui ne respectent pas cette contrainte
                    }
                }
            }
        }

        // √©tape 3 : fusionner les deux listes (outDict et foodict)
        for (String mot : foodict) {
            outDict.add(mot);
        }

        foodict = new ArrayList<>(outDict); // mise √† jour de la liste tampon

        // √©tape 4 : retirer les mots contenant des caract√®res impossibles
        for (String mot : foodict) {
            for (int i = 0; i < charImpossible.length(); i++) {
                if (mot.contains(charImpossible.charAt(i) + "")) { // v√©rifier si le mot contient un caract√®re interdit
                    outDict.remove(mot); // supprimer le mot
                }
            }
        }

        foodict = new ArrayList<>(outDict); // mise √† jour de la liste tampon

        // √©tape 5 : retirer les mots ayant les caract√®res mal plac√©s √† des positions sp√©cifiques
        for (String mot : foodict) {
            for (Integer posiMal : charsMalPlace.keySet()) {
                if (mot.charAt(posiMal) == charsMalPlace.get(posiMal)) { // v√©rifier si un caract√®re mal plac√© est √† une mauvaise position
                    outDict.remove(mot); // supprimer le mot
                }
            }
        }

        return outDict; // retourner la liste des mots filtr√©s
    }

    // m√©thode pour tester la pr√©sence de caract√®res mal plac√©s dans un mot
    private static Boolean testCharMalPlace(String mot, String lettres) {
        for (int i = 0; i < lettres.length(); i++) {
            String charActu = lettres.substring(i, i + 1);
            if (!mot.contains(charActu)) { // v√©rifier si le mot contient le caract√®re
                return false;
            }
        }
        return true;
    }

    // m√©thode pour s√©lectionner un mot al√©atoire dans le dictionnaire
    static String randomWord(ArrayList<String> dico) {
        Random random = new Random();
        int randomIndex = random.nextInt(dico.size()); // g√©n√©rer un index al√©atoire
        return dico.get(randomIndex); // retourner le mot √† cet index
    }

    // charger le motsMotus.txt
    public static ArrayList<String> chargerDictionnaire(String cheminFichier, int longueurMot) {
        OuvrirDB db = new OuvrirDB(cheminFichier);
        return new ArrayList<>(db.getOnePhrase(longueurMot));
    }

//     public static void main(String[] args) {
//         OuvrirDB db = new OuvrirDB("data/rules.txt"); // ouvrir la base de donn√©es
//         ArrayList<String> dico = new ArrayList<>(db.getOnePhrase(6)); // r√©cup√©rer une liste de mots
//         HashMap<Integer, Character> charsMalPlace = new HashMap<>();
//         charsMalPlace = EtatMot.checkWrongPlacement2("partir", "patate"); // v√©rifier les caract√®res mal plac√©s
//         choix("pa****", charsMalPlace, "zrq", dico); // appeler la m√©thode choix
//     }
}import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class Main extends JFrame{

    // MENU PRINCIPAL AFFICH√© AU BOOT.

    public Main(){
        // param√©trage de base du layout
        super("Motus et bouche cousue");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        // Image de fond
        ImageIcon icon = new ImageIcon("images/bienvenue.png");
        Image arrPlan = icon.getImage();

        // Panneau principal
        JPanel arrPanel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                g.drawImage(arrPlan, 0, 0, getWidth(), getHeight(), this);
            }
        };
        arrPanel.setLayout(new GridLayout(3,1,15,10)); // m√™me layout que l'ancien
        setContentPane(arrPanel);

        // Menu : cr√©ation
        JLabel titre = new JLabel("<html><center>Bienvenue dans Motus, une production ‚àö4 !</center></html>", JLabel.CENTER);
        titre.setFont(new Font("SansSerif", Font.BOLD, 14));
        titre.setForeground(Color.WHITE); // texte blanc pour la lisibilit√©

        JButton bouttonJouer = new JButton("Jouer");
        JButton bouttonRegles = new JButton("R√®gles");
        JButton buttonFermer = new JButton("Fermer");

        // Boutons : taille
        Dimension buttonSize = new Dimension(100, 30);
        bouttonJouer.setPreferredSize(buttonSize);
        bouttonRegles.setPreferredSize(buttonSize);
        buttonFermer.setPreferredSize(buttonSize);

        JPanel bouttonFrame = new JPanel(new FlowLayout(FlowLayout.CENTER,15,0));
        bouttonFrame.setOpaque(false); // pour ne pas cacher l‚Äôimage de fond

        // Boutons : param√©trage
        bouttonJouer.addActionListener(clic -> {
            new EcranChargement();
            dispose();
        });

        bouttonRegles.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent clic) {
                try {
                    // passer la r√©f√©rence √† la fen√™tre Main
                    new EcranRegle(Main.this);
                } catch (Exception e) {
                    dispose();
                    e.printStackTrace();
                }
            }
        });

        buttonFermer.addActionListener(e -> dispose());

        // Bouttons : position
        bouttonFrame.add(bouttonJouer);
        bouttonFrame.add(bouttonRegles);
        bouttonFrame.add(buttonFermer);

        arrPanel.add(titre); 
        arrPanel.add(new JLabel()); // permet espacement Titre / Boutons
        arrPanel.add(bouttonFrame);

        // Fen√™tre : position et param√©trage
        setSize(400, 300);
        setLocationRelativeTo(null);
        setVisible(true);
    }

    public static void main(String[] args) {
        new Main();
    }
}
public class MotPropose {
    private String proposition;
    private char[] etatMot;

    public MotPropose(String proposition, char[] etatMot) {
        this.proposition = proposition;
        this.etatMot = etatMot;
    }

    public String getProposition() {
        return proposition;
    }

    public char[] getEtatMot() {
        return etatMot;
    }
}
import java.util.ArrayList;

public class Mots {

    private final int nChar; // Length of the words
    private final ArrayList<String> line;

    // Initialiser liste : 1ier mot + nChar
    public Mots(String word) {
        this.line = new ArrayList<>();
        this.line.add(word);
        this.nChar = word.length();
    }

    // Getter de la liste
    public ArrayList<String> getLine() {
        return line;
    }

    // Getter du nombre de caract√®res
    public int getnChar() {
        return nChar;
    }

    // Ajout mot √† liste
    public void extend(String word) {
        if (word.length() != nChar) {
            throw new IllegalArgumentException("Taille diff√©rente : " + nChar);
        }
        line.add(word);
    }
}import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

public class OuvrirDB {

    private final HashMap<Integer, Mots> phrase; // int = taille du mot

    // Initialiser DB
    public OuvrirDB(String filePath) {
        phrase = new HashMap<>();
        createDict(filePath);
    }

    // Getter pour tous les mots
    public HashMap<Integer, Mots> getAllPhrase() {
        return phrase;
    }

    // Getter pour mots de taille voulue
    public ArrayList<String> getOnePhrase(int taille) {
        Mots mots = phrase.get(taille);
        return (mots != null) ? mots.getLine() : new ArrayList<>();
    }

    // Attraper un mot au hasard de taille voulue
    public String getRandomWord(int taille) {
        ArrayList<String> words = getOnePhrase(taille);
        if (words == null || words.isEmpty()) {
            throw new IllegalArgumentException("No words found for the specified length: " + taille);
        }
        Random random = new Random();
        return words.get(random.nextInt(words.size())).toUpperCase();
    }

    // Faire un dico depuis le fichier
    public void createDict(String nomfichier) {
        try (BufferedReader buf = new BufferedReader(new FileReader(nomfichier))) {
            String contentLine = buf.readLine();
            while (contentLine != null) {
                int fooKey = contentLine.length();
                if (phrase.get(fooKey) == null) {
                    phrase.put(fooKey, new Mots(contentLine));
                } else {
                    phrase.get(fooKey).extend(contentLine);
                }
                contentLine = buf.readLine();
            }
        } catch (IOException e) {
            System.err.println("Erreur sur le fichier : " + e.getMessage());
        }
    }

    // Static method to read rules from a file
    public static String lireRegle(String filePath) {
        StringBuilder out = new StringBuilder();
        try (BufferedReader buf = new BufferedReader(new FileReader(filePath))) {
            String line = buf.readLine();
            while (line != null) {
                out.append(line).append('\n');
                line = buf.readLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return out.toString();
    }
}public class ParametresJeu {

    public enum Mode {
        ORDI, 
        JOUEUR, 
        MORTEL;
    }

    private Mode mode;
    private String mot;
    private String difficulte;

    public ParametresJeu(Mode mode, String mot, String difficulte) {
        this.mode = mode;
        this.mot = mot;
        this.difficulte = difficulte;
    }

    public Mode getMode() {
        return mode;
    }

    public String getMot() {
        return mot;
    }

    public String getDifficulte() {
        return difficulte;
    }
}
